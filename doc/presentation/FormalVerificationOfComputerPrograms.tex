\documentclass[10pt]{beamer}

\usetheme[progressbar=frametitle]{metropolis}
\usepackage{appendixnumberbeamer}
\usepackage{bussproofs}
\usepackage{booktabs}
\usepackage[scale=2]{ccicons}

\usepackage{pgfplots}
\usepgfplotslibrary{dateplot}

\usepackage{xspace}
\newcommand{\themename}{\textbf{\textsc{metropolis}}\xspace}

\usepackage{listings}

\input{listings-coq}

\title{Formal Verification of Computer Programs}
\subtitle{A Primer}
% \date{\today}
\date{\date{}}
\author[shortname]{Vadim Zaliva \textsuperscript{1} \and Nika Pona \inst{2}}
\institute[shortinst]{\textsuperscript{1}Carnegie Mellon  University \and \inst{2} Digamma.ai}

% \titlegraphic{\hfill\includegraphics[height=1.5cm]{logo.pdf}}

\begin{document}

\maketitle

\begin{frame}{Outline}
    \begin{enumerate}
        \item What are formal methods?
        \item Proof assistants (Coq) mini-intro
        \item Reasoning about programs (semantics, specification, etc)
        \item Motivating example (strtoimax\_lim)
        \item Detailed example (strlen of similar)
        \item Other languages? (Javascript, LLVM, etc.)
        \item Other approaches (exraction)
        \item Conclusions
    \end{enumerate}
\end{frame}

\begin{frame}{Table of contents}
  \setbeamertemplate{section in toc}[sections numbered]
  \tableofcontents[hideallsubsections]
\end{frame}



\section{What are formal methods?}
\begin{frame}{Formal verification}
 
  We want to have high assurance that our code works as intended. One of the methods is formal verification. This means we want to produce a formal proof that our code works as intended. What does it mean and how do we do it?
  
  \begin{enumerate}
  \item We start by writing a \emph{specification} in a formal language which strictly defines how our program should behave.
  \item Then we define the \emph{semantics} of our program which describes how it actually behaves. 
  \item Finally we mathematically prove that semantics of our program matches our specification.
\end{enumerate}
  
\end{frame}

\begin{frame}{Coq intro}
  As a formal language we choose {\bf Gallina}, mechanized version of Calculus of Inductive Constructions (aka dependent type theory), which is a very expressive theory well studied in mathematical logic.

  \smallskip
  
  It is much more likely to make a mistake in a formal proof (which is typically way longer than the code), so we want assurance that our proof is correct.
  \smallskip
  
  Hence we use a proof assistant Coq: a program that checks that your proof is correct. It also provides an environment to make the construction of proofs easier. 
  
  
\end{frame}

\begin{frame}{What Coq does?}
  In Coq you can:
  \begin{itemize}
  
    \item define functions or predicates
   \item state mathematical theorems and software specifications
    \item  interactively develop formal proofs of these theorems
   \item machine-check these proofs by a relatively small certification kernel
    \item extract certified programs to languages like OCaml, Haskell or Scheme.
    \end{itemize}

  \end{frame}

  \begin{frame}[fragile]{Logic in Coq}

    \texttt{Prop} stands for Proposition: this is the type used for logical definitions.
    
  \begin{lstlisting}[language=Coq]

    Inductive False : Prop := .

    Inductive True : Prop :=
    | I : True.

    Theorem impl_to_and : (forall A B : Prop, A -> B -> A /\ B).

  \end{lstlisting}
  The theorem states that \texttt{impl\_to\_and} is a proof (to be constructed) of $\forall A \; B : \texttt{Prop}, A \rightarrow B \rightarrow A \wedge B$ or equivalently
that $\forall A \; B : \texttt{Prop}, A \rightarrow B \rightarrow A \wedge B$ is the type of \texttt{impl\_to\_and}. 
 
\end{frame}

\begin{frame}[fragile]{Basic Types}

  You can define basic inductive types using \texttt{Inductive} command:

  \begin{lstlisting}[language=Coq]

  Inductive bool : Set :=
    | true : bool
    | false : bool.

  \end{lstlisting}
  
   \begin{lstlisting}[language=Coq]

  Inductive nat : Set :=
    | O : nat
    | S : nat -> nat.
    
  \end{lstlisting}

  And state and prove theorems about them:

  \begin{lstlisting}[language=Coq]

    Theorem zero_lt_Sn : (forall n : nat, 0 < S n).

  \end{lstlisting}

   \begin{lstlisting}[language=Coq]

    Theorem bool_dec : (forall b : bool, b = true \/ b = false).

  \end{lstlisting}
 
\end{frame}

\begin{frame}[fragile]{Recursive functions}

  You can define recursive functions and use pattern-matching on inductive types.

  \begin{lstlisting}[language=Coq]

  Fixpoint fact (n : nat) : nat :=
    match n with
    | O => 1
    | S n' => n * fact n'
    end.

  \end{lstlisting}
  
Note that you can only write terminating functions in Coq. (Hence, you often get the termination proof ``for free'').
  
\end{frame}


  
\end{frame}



  
 
\end{frame}

  \begin{frame}{How does Coq work?}
     Programs, properties and proofs can be formalized in the same language due to the so-called Curry-Howard isomorphism (correspondence between programs and terms, proofs and types respectively). All logical judgments in Coq are typing judgments and 
thus checking the correctness of proofs amounts to type checking. We will see how Coq is used for veryfing programs in a bit. But first a motivating example.
    \end{frame}


\section{Motivating Example}
\begin{frame}{\texttt{asn\_strtoimax\_lim}}
In this talk we are concentrating on formal verification of existing imperative programs using Coq. We took a function \texttt{asn\_strtoimax\_lim} from \texttt{asn1c} compiler to test our approach on a real-life function. Informal specification from the comments: 

 \begin{quote}
 Parse the number in the given string until the given *end position,
 returning the position after the last parsed character back using the
 same (*end) pointer.
 WARNING: This behavior is different from the standard strtol/strtoimax(3).
\end{quote}

The code:
 \url{https://github.com/vlm/asn1c/blob/9f470d60faf6b994de6b9d6c0dbfb9279d9bb48d/skeletons/INTEGER.c#L1033}
\end{frame}

\begin{frame}{\texttt{asn\_strtoimax\_lim}}


While doing the correctness proof we found a bug, can you see it?

  \url{https://github.com/vlm/asn1c/issues/344}
  
\end{frame}



\begin{frame}[fragile]{\texttt{asn\_strtoimax\_lim}}
  Fixed version: \url{https://github.com/vlm/asn1c/blob/b361194599b46d97a398195e6a18f1d581f7fab9/skeletons/INTEGER.c#L1033}

  Is this fix OK?
  
\end{frame}

\begin{frame}{\texttt{asn\_strtoimax\_lim}}

This code has been extensively tested and used for 15 years. Formal verification guarantees absence of bugs this kind of bugs. 

\end{frame}

\section{Detailed example}


\begin{frame}[fragile]{Factorial example}
  Mathematical specification of factorial is recursive equation, for ($0 \leq n$) :
  \[ fact(0) = 1 \]
  \[ fact(n + 1) = fact(n)*(n+1) \]
  
  We can write it in Coq as a fixpoint (recursive) definition:
  \begin{lstlisting}[language=Coq]

  Fixpoint fact (n : nat) : nat :=
    match n with
    | O => 1
    | S n' => (S n') * fact n'
    end.

  \end{lstlisting}
  
  Note that this definition is also a functional program.
 
\end{frame}


\begin{frame}[fragile]{Factorial example: verifying a functional program}

  We can write a more efficient functional program to compute factorial

  \begin{lstlisting}[language=Coq]

  Fixpoint fact_acc (n : nat) (acc : nat) :=
    match n with
    | 0 => acc
    | S k => fact_acc k (n * acc)
    end.

  Definition fact' (n : nat) :=
    fact_acc n 1.

  \end{lstlisting}

  Now we want to show that it actually computes factorial. To do this we can show in Coq that:
   \begin{lstlisting}[language=Coq]
  Theorem fact'_correct : forall n, fact' n = fact n.
  \end{lstlisting}
 
\end{frame}

\begin{frame}{Factorial example: verifying a functional program}
Now using Coq's extraction mechanism we can automatically extract an OCaml or Haskell function that is provably correct. Alternatively, one could easily embed a functional language into Coq and reason about the existing implementation. But what if you want to verify code written in imperative language? Things get \emph{slightly} more complicated.
  \end{frame}


  \begin{frame}{Factorial example: verifying a C program}

    To be able to state theorems about C programs in Coq you need to embed the language into Coq, meaning model its syntax (as abstract syntax trees) and semantics (modelling execution of programs) in Coq. Luckily, this has been already done in the project called CompCert, a verified compiler for C, almost entirely written in Coq and proved to work according to its specification (\url{http://compcert.inria.fr/}).

    \begin{quote}
      The striking thing about our CompCert results is that the middle-end bugs we found in all other compilers are absent. As of early 2011,the under-development version of CompCert is the only compiler we have tested for which Csmith cannot find wrong-code errors.
    \end{quote} ({\it Finding and Understanding Bugs in C Compilers}, Yang et al., 2011)

  \end{frame}
    
  \begin{frame}{Verifying imperative programs}
    So using CompCert our approach is as follows:
  \begin{itemize}
  \item parse C code into an abstract syntax tree using C light\footnote{C light is a subset of C} generator of CompCert
  \item write a functional specification using CompCert's model of C light 
  \item reason about the C light program using operational semantics defined in CompCert
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Factorial example: verifying a C program}

 Factorial C implementation that we want to verify

\begin{lstlisting}

unsigned int factorial (unsigned int input) {
  unsigned int output = 1;
  while (input){
      output = output*input ;
      input = input - 1 ;
    } 
  return output ;
}

\end{lstlisting}

The specification stays the same. 

\end{frame}

\begin{frame}[fragile]{ Syntax of C programs in Coq}
C light AST corresponding to the factorial function: 
  \begin{lstlisting}[language=Coq]
(Ssequence
  (* int output = 1 *)
  (Sset _output (Econst_int (Int.repr 1) tuint)) 
  (Ssequence 
    (Swhile 
      (Etempvar _input tuint) (* while (input) *)
      (Ssequence  
        (Sset _output
          (Ebinop Omul (Etempvar _output tuint) 
          (* output = output*input *)
          (Etempvar _input tuint) tuint)) 
        (Sset _input
          (Ebinop Osub (Etempvar _input tuint) 
          (* input = input - 1 *)
          (Econst_int (Int.repr 1) tuint) tuint))))
            (* return output *)
    (Sreturn (Some (Etempvar _output tuint))))) |}.
     \end{lstlisting}
     
\end{frame}


\subsection{Semantics of C programs in Coq}

  \begin{frame}{Operational Semantics}
    Our goal is to prove that programs written in C light behave as intended. To do this we need to formalize the notion of meaning of a C light program. We do this using {\bf operational semantics}.

    \bigskip
    
    An operational semantics is a mathematical model of programming language execution. It is basically an interpreter defined formally.
    \bigskip
    
    We use big-step operational semantics used for all intermediate languages of CompCert.
  \end{frame}
  
  \begin{frame}{Operational Semantics}
    We assign primitive values to constants and then compositionally compute values of expressions and outcomes of statements.
   \begin{itemize}
    \item Each syntactic element (expressions and statements) is related to the intended result of executing this element.    
    \item Expressions are deterministically mapped to memory locations or values (integers, bool etc).
    \item The execution of statements depends on memory state and values stored in the local environment and produces {\bf outcomes} (break, normal, return), updated memory and local environment. Moreover, {\bf trace} of external calls is recorded.
      \end{itemize}
    \end{frame}
    \begin{frame}
      Go to factorial tutorial: \url{~/asn1verification/doc/tutorial/MiscExamples/factorial}
    \end{frame}

    \begin{frame}
      Going back to our first example:
      
       We wrote a formal specification of the function (based on the comment and analysis of the function), produced C light AST of the function using C light generator of CompCert and proved that the resulting AST evaluates to correct values on all valid inputs using operational semantics. Moreover, using CompCert's C memory model we can state properties about correct memory usage and heap and stack bounds.
      \end{frame}

\section{Other languages}

\begin{frame}{Other languages}

  \url{http://www.jscert.org/} JSCert: Certified JavaScript
  
  \end{frame}

\begin{frame}[allowframebreaks]{References}

  \bibliography{demo}
  \bibliographystyle{abbrv}

\end{frame}

\end{document}
